<!DOCTYPE html>
<html>
<head>
    <title>Super Customizable Cumulative Flow Diagram</title>
    <!--  (c) 2013,2014 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Thu Jan 25 2018 14:52:34 GMT-0700 (MST) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Jan 25 2018 14:52:34 GMT-0700 (MST)";
        var CHECKSUM = 32647669000;
    </script>
    
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
Ext.define('EndDateField', {
    extend: 'Ext.form.FieldContainer',
    alias: 'widget.enddatefield',

    requires: [
        'Rally.ui.DateField'
    ],

    mixins: [
        'Ext.form.field.Field',
    ],

    layout: {
        type: 'hbox'
    },

    initComponent: function() {
        this.callParent(arguments);

        this.add([
            {
                xtype: 'radiogroup',
                name: 'enddate',
                itemId: 'enddategroup',
                columns: 4,
                vertical: false,
                listeners: {
                    change: this._onChange,
                    scope: this,
                },
                items: [
                    {
                        name: 'enddate',
                        itemId: 'timebox',
                        boxLabel: 'Timebox End Date',
                        inputValue: 'timebox',
                        width: 150
                    },
                    {
                      name: 'enddate',
                      itemId: 'today',
                      boxLabel: 'Today',
                      inputValue: 'today',
                      width: 75
                    },
                    {
                        name: 'enddate',
                        itemId: 'specificdate',
                        boxLabel: 'Specific Date',
                        inputValue: 'specificdate',
                    },
                    {
                        xtype: 'rallydatefield',
                        itemId: 'enddatefield',
                        plugins: [
                            'rallyfieldvalidationui'
                        ],
                        margin: '0 0 0 10px'
                    }
                ]
            }
        ]);

        this.initField();
        this._sync();
    },

    _onChange: function() {
        this._sync();
    },

    _sync: function() {
        var hasTimeboxScope = !!this.context.getTimeboxScope();
        this.down('#timebox').setDisabled(!hasTimeboxScope);
        var dateEnabled = this.down('#enddategroup').getValue().enddate === 'specificdate';
        this.down('#enddatefield').setDisabled(!dateEnabled);
    },

    setValue: function (value) {
        var hasTimeboxScope = !!this.context.getTimeboxScope();
        var radioValue = (hasTimeboxScope && (value === 'timebox' || !value)) ? 'timebox' : 
          (value === 'today' ? 'today' : 'specificdate');
        var isSpecificDate = radioValue === 'specificdate';
        this.down('#enddategroup').setValue({ enddate: radioValue });
        if (isSpecificDate && value) {
            this.down('#enddatefield').setValue(Rally.util.DateTime.fromIsoString(value));
        }
        return this;
    },

    getValue: function () {
        var radioValue = this.down('#enddategroup').getValue().enddate;
        var value = radioValue === 'specificdate' ? Rally.util.DateTime.toIsoString(this.down('#enddatefield').getValue()) : radioValue;
        return value;
    }
});
Ext.define('StartDateField', {
    extend: 'Ext.form.FieldContainer',
    alias: 'widget.startdatefield',

    requires: [
        'Rally.ui.DateField'
    ],

    mixins: [
        'Ext.form.field.Field',
    ],

    layout: {
        type: 'hbox'
    },

    initComponent: function() {
        this.callParent(arguments);

        this.add([
            {
                xtype: 'radiogroup',
                name: 'startdate',
                itemId: 'startdategroup',
                columns: 3,
                vertical: false,
                listeners: {
                    change: this._onChange,
                    scope: this,
                },
                items: [
                    {
                        name: 'startdate',
                        itemId: 'timebox',
                        boxLabel: 'Timebox Start Date',
                        inputValue: 'timebox',
                        width: 150
                    },
                    {
                        name: 'startdate',
                        itemId: 'specificdate',
                        boxLabel: 'Specific Date',
                        inputValue: 'specificdate',
                    },
                    {
                        xtype: 'rallydatefield',
                        itemId: 'startdatefield',
                        plugins: [
                            'rallyfieldvalidationui'
                        ],
                        margin: '0 0 0 10px'
                    }
                ]
            }
        ]);

        this.initField();
        this._sync();
    },

    _onChange: function() {
        this._sync();
    },

    _sync: function() {
        var hasTimeboxScope = !!this.context.getTimeboxScope();
        this.down('#timebox').setDisabled(!hasTimeboxScope);
        this.down('#startdatefield').setDisabled(this.down('#startdategroup').getValue().startdate === 'timebox');
    },

    setValue: function (value) {
        var hasTimeboxScope = !!this.context.getTimeboxScope();
        var radioValue = (hasTimeboxScope && (value === 'timebox' || !value)) ? 'timebox' : 'specificdate';
        this.down('#startdategroup').setValue({ startdate: radioValue });
        var isSpecificDate = radioValue === 'specificdate';
        if (isSpecificDate && value) {
            this.down('#startdatefield').setValue(Rally.util.DateTime.fromIsoString(value));
        }
        return this;
    },

    getValue: function () {
        var radioValue = this.down('#startdategroup').getValue().startdate;
        var value = radioValue === 'timebox' ? 'timebox' : Rally.util.DateTime.toIsoString(this.down('#startdatefield').getValue());
        return value;
    }
});
Ext.define("Rally.TechnicalServices.CFDCalculator", {
    extend: "Rally.data.lookback.calculator.TimeSeriesCalculator",

    config: {
        /*
         * Required
         */
        group_by_field: null,
        /*
         * Name of field that holds the value to add up
         * (Required if type is "sum")
         */
        value_field: null, 
        /*
         * allowed_values (Required): array of available values in field to group by
         */
         allowed_values: null,
         /*
          * allowed_oids is an array of ObjectIDs that are allowed to be reported on
          * This lets you restrict to a set of items that currently met a WSAPI filter 
          * (e.g., if I want to apply a tag to stories and then see what those stories' histories
          * have been. If I put tag in the lookback query, then that tag has to have been assigned
          * yesterday to see what happened to the items yesterday)
          * 
          * leave as null to allow everything
          */
         allowed_oids: null,
         granularity: 'day',
         /*
          * value_type: 'sum' | 'count' whether to count on given field or to count the records
          */
         value_type: 'sum',
         endDate: null,
         startDate: null
    },
    constructor: function (config) {
        this.callParent(arguments);

        if (this.value_field == 'Count'){
            this.value_type = 'count';
        }
        
        if (this.value_type == 'sum' && (!this.allowed_values || this.allowed_values.length == 0) ) {
            throw "Cannot create Rally.TechnicalServices.CFDCalculator without allowed_values";
        }
        if (!this.group_by_field) {
            throw "Cannot create Rally.TechnicalServices.CFDCalculator without group_by_field";
        }
        if (this.value_type == 'sum' && !this.value_field) {
            throw "Cannot create Rally.TechnicalServices.CFDCalculator by sum without value_field";
        }
        
        this._prepareDates();
        
    },
    /*
     * The goal is to have two dates, in order, that are ISO strings
     */
    _prepareDates: function() {
        if ( this.startDate == "" ) { this.startDate = null; }
        if ( this.endDate == "" )   { this.endDate   = null; }
        
        if ( this.startDate && typeof(this.startDate) === 'object' ) {
            this.startDate = Rally.util.DateTime.toIsoString(this.startDate);
        }
        if ( this.endDate && typeof(this.endDate) === 'object' ) {
            this.endDate = Rally.util.DateTime.toIsoString(this.endDate);
        }
        
        if ( this.startDate && ! /-/.test(this.startDate)  ){
            throw "Failed to create Rally.TechnicalServices.CFDCalculator: startDate must be a javascript date or ISO date string";
        }

        if ( this.endDate && ! /-/.test(this.endDate)  ){
            throw "Failed to create Rally.TechnicalServices.CFDCalculator: endDate must be a javascript date or ISO date string";
        }
    
        // switch dates
        if ( this.startDate && this.endDate ) {
            if ( this.startDate > this.endDate ) {
                var holder = this.startDate;
                this.startDate = this.endDate;
                this.endDate = holder;
            }
        }
        
        if ( this.startDate ) { this.startDate = this.startDate.replace(/T.*$/,""); }
        if ( this.endDate ) { this.endDate = this.endDate.replace(/T.*$/,""); }
    },
    /*
     * How to measure
     * 
     * { 
     *      field       : the field that has the value to add up on each day
     *      as          : the name to display in the legend
     *      display     : "line" | "column" | "area"
     *      f           : function to use (e.g., "sum", "filteredSum"
     *      filterField : (when f=filteredSum) field with values used to group by (stacks on column)
     *      filterValues: (when f=filteredSum) used to decide which values of filterField to show
     */
    getMetrics: function () {
        
        var metric = {
            f: 'groupBySum',
            field: this.value_field, 
            groupByField: this.group_by_field, 
            allowedValues: this.allowed_values,
            display:'area'
        };
                
        if ( this.value_type == "count" ) {
            metric.f = 'groupByCount';
        }
        
        return [ metric ];
    },
    /*
     * Modified to allow groupBySum/groupByCount to spit out stacked area configs
     */
    _buildSeriesConfig: function (calculatorConfig) {
        var aggregationConfig = [],
            metrics = calculatorConfig.metrics,
            derivedFieldsAfterSummary = calculatorConfig.deriveFieldsAfterSummary;

        _.each(metrics, function(metric, i) {
            if ( metric.f == "groupBySum" || metric.f == "groupByCount") {
                var type = metric.f.replace(/groupBy/,"");
                
                if ( ! metric.allowedValues ) {
                    throw "Rally.TechnicalServices.CFDCalculator requires setting 'allowed_values'";
                }
                Ext.Array.each(metric.allowedValues,function(allowed_value){
                    aggregationConfig.push({
                        f: type,
                        name: allowed_value,
                        type: metric.display || "area",
                        dashStyle: metric.dashStyle || "Solid",
                        stack: 1
                    });
                });
            } else {
                aggregationConfig.push({
                    name: metric.as || metric.field,
                    type: metric.display,
                    dashStyle: metric.dashStyle || "Solid"
                });
            }
        });

        for (var j = 0, jlength = derivedFieldsAfterSummary.length; j < jlength; j += 1) {
            var derivedField = derivedFieldsAfterSummary[j];
            aggregationConfig.push({
                name: derivedField.as,
                type: derivedField.display,
                dashStyle: derivedField.dashStyle || "Solid"
            });
        }

        return aggregationConfig;
    },
    /*
     * WSAPI will give us allowed values that include "", but the
     * snapshot will actually say null
     * 
     */
    _convertNullToBlank:function(snapshots){
        var number_of_snapshots = snapshots.length;
        for ( var i=0;i<number_of_snapshots;i++ ) {
            if ( snapshots[i][this.group_by_field] === null ) {
                snapshots[i][this.group_by_field] = "";
            }
        }
        return snapshots;
    },
    _getAllowedSnapshots:function(snapshots){
        var allowed_snapshots = [];
        var allowed_oids = this.allowed_oids;
        
        if ( allowed_oids.length === 0 ) {
            return [];
        }
        var number_of_snapshots = snapshots.length;
        for ( var i=0;i<number_of_snapshots;i++ ) {
            if (Ext.Array.contains(allowed_oids,snapshots[i].ObjectID)) {
                allowed_snapshots.push(snapshots[i]);
            }
        }
        return allowed_snapshots;
    },
    // override runCalculation to change false to "false" because highcharts doesn't like it
    runCalculation: function (snapshots) {
        console.log(snapshots);
        var calculatorConfig = this._prepareCalculatorConfig(),
            seriesConfig = this._buildSeriesConfig(calculatorConfig);

        var calculator = this.prepareCalculator(calculatorConfig);
        
        var clean_snapshots = this._convertNullToBlank(snapshots);
        if (this.allowed_oids !== null) {
            clean_snapshots = this._getAllowedSnapshots(clean_snapshots);
        }
        if ( clean_snapshots.length > 0 ) {
            calculator.addSnapshots(clean_snapshots, this._getStartDate(clean_snapshots), this._getEndDate(clean_snapshots));
        }
        var chart_data = this._transformLumenizeDataToHighchartsSeries(calculator, seriesConfig);
        
        // check for false
        Ext.Array.each(chart_data.series,function(series){
            if ( series.name === "" ) {
                series.name = "None";
            }
            
            if (series.name === false) {
                series.name = "False";
            }
            
            if (series.name == true) {
                series.name = "True";
            }
        });
        
        return chart_data;
    }
        
        
});
/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        if(window.console) {
          console.log.apply(console,output_args);
        }
    }

});

Ext.define('TSStringFilter',{
    extend: 'Rally.data.QueryFilter',
    config: {
        query_string: ''
    },
    constructor: function(config) {
        this.mergeConfig(config);
        this.callParent([this.config]);
    },
    _createQueryString: function(property, operator, value) {
        this.filter = this.fromQueryString(this.query_string);
        return this.filter.toString();
    },
    /**
     * Converts a query string into a Rally compatible QueryFilter
     * @static
     * @param {String} query The query string to convert into a QueryFilter
     * @return {Rally.data.wsapi.Filter} A Rally.data.wsapi.Filter that will convert back to a query string if toString() is called
     */
    fromQueryString: function (query) {
        var parser = Ext.create('Rally.data.util.QueryStringParser', {
            string: query
        });

        var initial_expression = parser.parseExpression();
        return initial_expression;
    }
});
Ext.override(Rally.data.util.QueryStringParser,{
  applyOperators: function (operators, operator) {
        if (!operators.length) {
            return this.parseNextTerm();
        }

        if (!operator) {
            operator = operators[0];
        }

        var property = this.applyOperators(operators.slice(1));

        while (this.peek() === operator) {
            this.consume(operator);
            var value = this.applyOperators(operators.slice(1));
            if ( operator == "AND" || operator == "OR" ) {
                property = Ext.create('Rally.data.QueryFilter', {
                    property: property,
                    operator: operator,
                    value: this._convertToType(value)
                });
            } else {
                value = this._convertKeywords(property,operator,value);
                if (typeof(value) == "object" ) {
                    property = value;
                } else {
                    property = Ext.create('Rally.data.QueryFilter', {
                        property: property,
                        operator: operator,
                        value: this._convertToType(value)
                    });
                }
            }
        }
        return property;
    },
    /**
     * Do date math
     **/
    _convertKeywords: function(property,operator,value) {
        var xform_value = value;
        if ( operator != "AND" && operator != "OR" ) {
            if ( this._isDateKeyword(value) ) {
                var base_js_date = this._getBaseJSDate(value);
                if ( operator == "<" || operator == ">" || operator == ">=") {
                    xform_value = this._getIsoMidnight(base_js_date);
                } else if ( operator == "<=") {
                    xform_value = this._getIsoMidnight(Rally.util.DateTime.add(base_js_date,"day",1));
                } else if ( operator == "=" ) {
                    // yesterday and tomorrow do NOT include today, but all others do
                    if ( value == "tomorrow" || value == "yesterday" || value == "today") {
                        xform_value = Ext.create('Rally.data.QueryFilter', {
                            property: property,
                            operator: ">",
                            value: this._getIsoMidnight(base_js_date)
                        }).and(Ext.create('Rally.data.QueryFilter', {
                            property: property,
                            operator: "<",
                            value: this._getIsoMidnight(Rally.util.DateTime.add(base_js_date,"day",1))
                        }));                        
                    } else {
                        // everything less than today
                        var date_1 = base_js_date;
                        var date_2 = new Date();
                        
                        if ( date_1 > date_2 ) {
                            // include today by starting at beginning of day
                            xform_value = Ext.create('Rally.data.QueryFilter', {
                                property: property,
                                operator: ">",
                                value: this._getIsoMidnight(date_2)
                            }).and(Ext.create('Rally.data.QueryFilter', {
                                property: property,
                                operator: "<",
                                value: this._getIsoMidnight(date_1)
                            }));
                        } else {
                            // include today by starting at end of day when going back
                            xform_value = Ext.create('Rally.data.QueryFilter', {
                                property: property,
                                operator: ">",
                                value: this._getIsoMidnight(date_1)
                            }).and(Ext.create('Rally.data.QueryFilter', {
                                property: property,
                                operator: "<",
                                value: this._getIsoMidnight(Rally.util.DateTime.add(date_2,"day",1))
                            }));
                        }
                    }
                }
            }
        } 
        return xform_value;
    },
    _getBaseJSDate: function(keyword){
        var lc_keyword = Ext.util.Format.lowercase(keyword);
        var today = new Date();
        return Rally.util.DateTime.add(today,"day",this.periodShifters[lc_keyword]);
    },
    _isDateKeyword: function(keyword) {
        var isKeyword = false;
        var valid_keywords = [
            "today", "tomorrow", "yesterday",
            "lastweek","lastmonth","lastquarter","lastyear",
            "nextweek","nextmonth","nextquarter","nextyear"
        ];
        if ( Ext.Array.indexOf(valid_keywords,Ext.util.Format.lowercase(keyword)) > -1 ) {
            isKeyword = true;
        }
        return isKeyword;
    },
    periodShifters: {
        "today": 0,
        "tomorrow":1, 
        "yesterday":-1,
        "lastweek":-6,
        "lastmonth":-29,
        "lastquarter":-89,
        "lastyear":-364,
        "nextweek":7,
        "nextmonth":30,
        "nextquarter":90,
        "nextyear":365       
    },
    /**
     * 
     */
    _getIsoMidnight: function(js_date) {
        var js_at_midnight = new Date(Ext.clone(js_date).setHours(0,0,0,0));
        var iso_at_midnight = Rally.util.DateTime.toIsoString(js_at_midnight).replace(/T.*$/,"");
        return iso_at_midnight;
    }
});
Ext.define('Rally.technicalservices.util.Utilities', {
    singleton: true,
    hashToArray: function(hash) {
        var result = [];
        for ( var key in hash ) {
            result.push(hash[key]);
        }
        return result;
    }
    
});
Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    settingsScope: 'app',
    layout: 'fit',
    items: [
        {
          xtype:'container',
          itemId:'display_box',
          layout: {
            type: 'vbox',
            align: 'stretch'
          },
          items: [
              { xtype: 'rallyleftright', itemId: 'header', height: 30 },
              { xtype: 'container', itemId: 'filterContainer'},
              { xtype: 'container', itemId: 'chartContainer', layout: 'fit', flex: 1 },
            ]
        }
    ],
    launch: function() {
        if ( ! this.getSetting('type_path') ) {
            this._showMissingSettingMessage('No settings applied.  Select "Edit App Settings." from the gear menu.');
        } else {
            this._refresh();
        }  
    },
    _showMissingSettingMessage: function(message) {
        this.down('#chartContainer').add({
            xtype: 'container',
            html: message
        });
    },
    onTimeboxScopeChange: function () {
        this.callParent(arguments);

        this._refresh();
    },
    _addHeaderControls: function() {
        var blackListFields = ['FlowState'],
            whiteListFields = ['Milestones', 'Tags'],
            modelNames = [this.model.typePath];
        this.down('#header').getLeft().add({
            xtype: 'rallyinlinefiltercontrol',
            context: this.getContext(),
            height: 26,
            align: 'left',
            inlineFilterButtonConfig: {
                stateful: true,
                stateId: this.getContext().getScopedStateId('inline-filter'),
                context: this.getContext(),
                modelNames: modelNames,
                filterChildren: false,
                inlineFilterPanelConfig: {
                    quickFilterPanelConfig: {
                        defaultFields: ['ArtifactSearch', 'Owner'],
                        addQuickFilterConfig: {
                            blackListFields: blackListFields,
                            whiteListFields: whiteListFields
                        }
                    },
                    advancedFilterPanelConfig: {
                        advancedFilterRowsConfig: {
                            propertyFieldConfig: {
                                blackListFields: blackListFields,
                                whiteListFields: whiteListFields
                            }
                        }
                    }
                },
                listeners: {
                    inlinefilterchange: this._onFilterChange,
                    inlinefilterready: function (inlineFilterPanel) {
                      this.down('#filterContainer').add(inlineFilterPanel);
                    },
                    scope: this
                }
            }
        });

        var isIE = this._isIE();
        this.down('#header').getRight().add({
            xtype: 'rallybutton',
            disabled: isIE,
            cls: 'secondary rly-small',
            margin: '3px 20px 0 0',
            frame: false,
            iconCls: 'icon-export',
            toolTipConfig: {
                html: isIE ? 'Export is currently not supported in Microsoft browsers.' : 'Export',
                anchor: 'top',
                hideDelay: 0
            },
            listeners: {
                click: this._onExportClick,
                scope: this
            }
        });
    },

    _isIE: function() {
        var ua = window.navigator.userAgent;
        return ua.indexOf('MSIE ') > 0 ||
            ua.indexOf('Trident/') > 0 ||
            ua.indexOf('Edge/') > 0;
    },

    _onFilterChange: function (inlineFilterButton) {
        this.filterInfo = inlineFilterButton.getTypesAndFilters();
        this._getOIDsAndMakeChart(this.allowedValues);
    },

    _onExportClick: function () {
        if (!this._isIE()) {
            var link = document.createElement('a');
            var chartData = this.down('rallychart').chartData;
            var data = _.reduce(chartData.categories, function(accum, category, i) {
                var row = [category];
                _.each(chartData.series, function(series) {
                    row.push(series.data[i]);
                });
                accum.push(row.join(','));
                return accum;
            }, [['Date'].concat(_.pluck(chartData.series, 'name')).join(',')]);
            link.setAttribute('href', 'data:text/csv;charset=utf-8,' + encodeURI(data.join('\n')));
            link.setAttribute('download', 'cfd.csv');
            link.click();
        }
    },

    _getChartTitle: function(type_path,group_by_field){
        var type = this._deCamelCase(type_path);
        var field = this._deCamelCase(group_by_field);
        var main_title = type + " grouped by " + field;
        
        var title = main_title;
        var query_string = this.getSetting('query_string');
        if ( query_string ) {
            //  title += "<br/>Filtered with " + query_string;
            title = "";
        }
        return title;
    },

    _deCamelCase: function(camelCaseText){
        this.logger.log("_deCamelCase",camelCaseText);
        
        var spaced_out_text = camelCaseText.replace( /([A-Z])/g, " $1" );
        var initial_cap_text = spaced_out_text.charAt(0).toUpperCase() + spaced_out_text.slice(1);
        var removed_custom_field_prefix = initial_cap_text.replace(/^C_ /,"");
        
        this.logger.log(" .. ", removed_custom_field_prefix);
        return removed_custom_field_prefix;
    },

    _getStartDate: function() {
        var startDate = this.getSetting('start_date');
        if (startDate === 'timebox') {
            var timeboxScope = this.getContext().getTimeboxScope();
            return timeboxScope && timeboxScope.getRecord() && timeboxScope.getStartDate();
        } else {
            return startDate;
        }
    },

    _getEndDate: function() {
        var endDate = this.getSetting('end_date');
        if (endDate === 'timebox') {
            var timeboxScope = this.getContext().getTimeboxScope();
            return timeboxScope && timeboxScope.getRecord() && timeboxScope.getEndDate();
        } else if (endDate === 'today') {
            return Rally.util.DateTime.toIsoString(new Date()); 
        } else {
            return endDate;
        }
    },

    _preProcess: function() {
        var startDate = this._getStartDate();
        var endDate = this._getEndDate();

        if (!startDate) {
            this._showMissingSettingMessage('No start date available.  Select "Edit App Settings." from the gear menu.');
        } else if (!endDate) {
          this._showMissingSettingMessage('No end date available.  Select "Edit App Settings." from the gear menu.');
        } else {
            this._getAllowedValues().then({
                scope: this,
                success: function(allowedValues) {
                  this.allowedValues = allowedValues;
                  this._addHeaderControls();
                },
                failure:function(message){
                    this.down('#chartContainer').add({xtype:'container',html:'message'});
                }
            });
        }
    },
    _getAllowedValues:function(){
        var deferred = Ext.create('Deft.Deferred');
        var type_path = this.getSetting('type_path');
        var group_by_field = this.getSetting('group_by_field');
        
        var allowed_values = [];
        
        Rally.data.ModelFactory.getModel({
            type: type_path,
            success: function(model){
                this.model = model;
                var field = model.getField(group_by_field);
                var attribute_definition = field.attributeDefinition;
                if ( attribute_definition && attribute_definition.AttributeType == "BOOLEAN" ) {
                    deferred.resolve([true,false]);
                } else {
                    field.getAllowedValueStore().load({
                        callback: function(values,operation,success) {
                            Ext.Array.each(values, function(value){
                                allowed_values.push(value.get('StringValue'));
                            });
                            deferred.resolve(allowed_values);
                        }
                    });
                }
            },
            scope: this
        });
        return deferred.promise;
    },
    _findOIDsByQuery: function(model, filters) {
        this.logger.log("_findOIDsByQuery");
        this.down('#chartContainer').setLoading("Loading Filtered Data");

        var deferred = Ext.create('Deft.Deferred');
        
        Ext.create('Rally.data.WsapiDataStore',{
            model: model,
            autoLoad: true,
            limit: Infinity,
            pageSize: 2000,
            filters: filters,
            fetch: ['ObjectID'],
            listeners: {
                scope: this,
                load: function(store,items,successful,opts){
                    this.logger.log("wsapi load",successful,opts);
                    if ( successful ) {
                        var oids = [];
                        Ext.Array.each(items, function(item){
                            oids.push(item.get('ObjectID'));
                        });
                        this.logger.log("back from wsapi with",oids);
                        this.down('#chartContainer').setLoading(false);
                        deferred.resolve(oids);
                    } else {
                        this.down('#chartContainer').setLoading(false);
                        deferred.reject("Error loading filter");
                    }
                }
            }
        });
        return deferred.promise;
    },
    _getOIDsAndMakeChart: function(allowed_values) {
        this.down('#chartContainer').removeAll();
        
        var type_path = this.getSetting('type_path');
        var query_string = this.getSetting('query_string');
        var timeboxScope = this.getContext().getTimeboxScope();
        var filters = [].concat(this.filterInfo.filters);
        if (timeboxScope && timeboxScope.isApplicable(this.model)) {
          filters.push(timeboxScope.getQueryFilter());
        }
        if (query_string) {
          filters.push(Ext.create('TSStringFilter',{query_string:query_string}));
        }
        
        if (filters.length) {
            this.logger.log("Using query:", Rally.data.wsapi.Filter.and(filters).toString());
        }

        this._findOIDsByQuery(type_path, filters).then({
            scope: this,
            success: function(oids){
                this._makeChart(allowed_values,oids);
            },
            failure: function(error) {
                alert("Error while trying to apply filter");
            }
        });
    },
    _makeChart: function(allowed_values,allowed_oids) {
        var me = this;
        
        var project = this.getContext().getProject().ObjectID;
        var type_path = this.getSetting('type_path');
        var group_by_field = this.getSetting('group_by_field');
        var start_date = this._getStartDate();
        var end_date = this._getEndDate();
        
        var value_field = this.getSetting('metric_field');
        
        this.logger.log("Making chart for ", type_path, " on ", group_by_field);
        this.logger.log("  Start Date/End Date: ", start_date, end_date);
        this.logger.log("  Allowed Values: ", allowed_values);
        
        var chart_title = this._getChartTitle(type_path,group_by_field);
        this.logger.log("  Title: ", chart_title);
        
        this.down('#chartContainer').add({
            xtype:'rallychart',
            chartColors: [
                "#FF8200", // $orange
                "#F6A900", // $gold
                "#FAD200", // $yellow
                "#8DC63F", // $lime
                "#1E7C00", // $green_dk
                "#337EC6", // $blue_link
                "#005EB8", // $blue
                "#7832A5", // $purple,
                "#DA1884",  // $pink,
                "#C0C0C0" // $grey4
            ],
            storeType: 'Rally.data.lookback.SnapshotStore',
            calculatorType: 'Rally.TechnicalServices.CFDCalculator',
            calculatorConfig: {
                startDate: start_date,
                endDate: end_date,/*
                /*tz: "America/Anchorage",*/
                allowed_values: allowed_values,
                allowed_oids: allowed_oids,
                value_field: value_field,
                group_by_field: group_by_field
            },
            storeConfig: {
                find: {
                    _TypeHierarchy: type_path,
                    ObjectID: { $in: allowed_oids },
                    Children: null //only applies to stories
                },
                hydrate: [group_by_field],
                fetch: [group_by_field,value_field],
                removeUnauthorizedSnapshots : true,
                useHttpPost: true,
                compress: true
            },
            chartConfig: {
                 chart: {
                     zoomType: 'xy',
                     events: {
                        redraw: function () {
//                            me.logger.log('howdy');
//                            me._preProcess();
                        }
                     }
                 },
                 title: {
                     text: chart_title
                 },
                 xAxis: {
                     tickmarkPlacement: 'on',
                     tickInterval: 30,
                     title: {
                         text: ''
                     }
                 },
                 yAxis: [
                     {
                         title: {
                             text: value_field
                         }
                     }
                 ],
                 plotOptions: {
                    series: {
                        marker: { enabled: false },
                        stacking: 'normal'
                    }
                }
            }
        });
    },
    isExternal: function(){
      return typeof(this.getAppId()) == 'undefined';
    },
    
    
    /********************************************
    /* for drop-down filtering
    /*
    /********************************************/
    _filterOutExceptChoices: function(store) {
        store.filter([{
            filterFn:function(field){ 
                var attribute_definition = field.get('fieldDefinition').attributeDefinition;
                var attribute_type = null;
                if ( attribute_definition ) {
                    attribute_type = attribute_definition.AttributeType;
                }
                if (  attribute_type == "BOOLEAN" ) {
                    return true;
                }
                if ( attribute_type == "STRING" || attribute_type == "STATE" ) {
                    if ( field.get('fieldDefinition').attributeDefinition.Constrained ) {
                        return true;
                    }
                }
                if ( field.get('name') === 'State' ) { 
                    return true;
                }
                return false;
            } 
        }]);
    },
    _addCountToChoices: function(store){
        store.add({name:'Count',value:'Count',fieldDefinition:{}});
    },
    _filterOutExceptNumbers: function(store) {
        store.filter([{
            filterFn:function(field){ 
                var field_name = field.get('name');

                if ( field_name == 'Formatted ID' || field_name == 'Object ID' ) {
                    return false;
                }
                if ( field_name == 'Latest Discussion Age In Minutes' ) {
                    return false;
                }
                
                if ( field_name == 'Count' ) { return true; }
                
                var attribute_definition = field.get('fieldDefinition').attributeDefinition;
                var attribute_type = null;
                if ( attribute_definition ) {
                    attribute_type = attribute_definition.AttributeType;
                }
                if (  attribute_type == "QUANTITY" || attribute_type == "INTEGER" || attribute_type == "DECIMAL" ) {
                    return true;
                }

                return false;
            } 
        }]);
    },
        
    /********************************************
    /* Overrides for App class
    /*
    /********************************************/
    //getSettingsFields:  Override for App    
    getSettingsFields: function() {
        var me = this;
        
        return [
        {
            name: 'type_path',
            xtype:'rallycombobox',
            displayField: 'DisplayName',
            fieldLabel: 'Artifact Type',
            autoExpand: true,
            storeConfig: {
                model:'TypeDefinition',
                filters: [
                  {property:'Restorable',value:true}
                ]
            },
            labelWidth: 100,
            labelAlign: 'left',
            minWidth: 200,
            margin: 10,
            valueField:'TypePath',
            bubbleEvents: ['select','ready'],
            readyEvent: 'ready'
        },
        {
            name: 'group_by_field',
            xtype: 'rallyfieldcombobox',
            fieldLabel: 'Group By',
            labelWidth: 100,
            labelAlign: 'left',
            minWidth: 200,
            margin: 10,
            autoExpand: false,
            alwaysExpanded: false,
            handlesEvents: { 
                select: function(type_picker) {
                    this.refreshWithNewModelType(type_picker.getValue());
                },
                ready: function(type_picker){
                    this.refreshWithNewModelType(type_picker.getValue());
                }
            },
            listeners: {
                ready: function(field_box) {
                    me._filterOutExceptChoices(field_box.getStore());
                }
            },
            readyEvent: 'ready'
        },
        {
            name: 'metric_field',
            xtype: 'rallyfieldcombobox',
            fieldLabel: 'Measure',
            labelWidth: 100,
            labelAlign: 'left',
            minWidth: 200,
            margin: 10,
            autoExpand: false,
            alwaysExpanded: false,
            handlesEvents: { 
                select: function(type_picker) {
                    this.refreshWithNewModelType(type_picker.getValue());
                },
                ready: function(type_picker){
                    this.refreshWithNewModelType(type_picker.getValue());
                }
            },
            listeners: {
                ready: function(field_box) {
                    me._addCountToChoices(field_box.getStore());
                    me._filterOutExceptNumbers(field_box.getStore());
                    var value = me.getSetting('metric_field');
                    if ( value ) {
                        field_box.setValue(value);
                    }
                    if ( !field_box.getValue() ) {
                        field_box.setValue( field_box.getStore().getAt(0) );
                    }
                }
            },
            readyEvent: 'ready'
        },
        {
            name: 'start_date',
            xtype: 'startdatefield',
            fieldLabel: 'Start Date',
            labelWidth: 100,
            labelAlign: 'left',
            margin: 10
        },
        {
            name: 'end_date',
            xtype: 'enddatefield',
            fieldLabel: 'End Date',
            labelWidth: 100,
            labelAlign: 'left',
            margin: 10
        },
        {
            xtype:'textareafield',
            grow: true,
            name:'query_string',
            labelAlign: 'top',
            width: 250,
            margin: 10,
            fieldLabel:'Limit to items that currently meet this query:'
        }];
    },

    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings) {
        if (this.isExternal()) {
            //Build and save column settings...this means that we need to get the display names and multi-list
            this.logger.log('onSettingsUpdate',settings);
            this._refresh();     
        }
    },

    _refresh: function() {
      this.down('#chartContainer').removeAll();
      this.down('#header').getLeft().removeAll();
      this.down('#header').getRight().removeAll();
      this.down('#filterContainer').removeAll();
      this._preProcess();
    }
});

            
               Rally.launchApp('CustomApp', {
                   name: 'Super Customizable Cumulative Flow Diagram'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width:5%;
}
    </style>

</head>
<body></body>
</html>